/**
 * File:	modules/Wagon.ycp
 * Package:	WAGON
 * Summary:	Functions and handlers for WAGON
 * Authors:	Lukas Ocilka <locilka@suse.cz>
 * Internal
 *
 * $Id$
 *
 * Module for handling WAGON.
 *
 */

{
    module "Wagon";

    textdomain "wagon";

    import "Installation";
    import "PackageCallbacks";
    import "CommandLine";
    import "Mode";
    import "Stage";
    import "Directory";
    import "XML";
    import "ProductControl";
    import "Popup";
    import "Label";
    import "Report";
    import "ProductFeatures";
    import "Update";
    import "FileUtils";
    import "String";

    boolean running_by_applet = false;

    string update_workflow_type = "manual";

    // Products installed for the time of the migration
    global list <string> migration_products = [];

    // Products installed before the migration
    global list <map <string, string> > products_before_migration = [];

    // Repositories that were disabled by wagon during migration
    // List of aliases (unique identification)
    // BNC #573092
    global list <string> disabled_repositories = [];
    global list <string> repositories_to_disable = [];

    // When aborting before the real migration starts, we can still
    // revert to the old products
    global boolean abort_can_revert_products = true;

    // Registration can be skipped, this variable tells whether some repos were already
    // added by registration
    global boolean repos_already_registered = false;

    // Script suse_register changes the repositories automatically.
    // Additionally, Wagon also disables some repositories. This option provides
    // the possibility to check what was changed and how and/or add/remove some more.
    // BNC #579905
    global boolean check_repositories_manually = false;

    string check_repos_module = "wagon_check_repositories";

    global void SetUpdateWorkflow (string new_update_workflow_type) {
	// FIXME: check

	y2milestone ("New workflow type: %1", new_update_workflow_type);
	update_workflow_type = new_update_workflow_type;
    }

    global string GetUpdateWorkflow () {
	return update_workflow_type;
    }

    void ResetWorkflowSteps () {
	ProductControl::UnDisableAllModulesAndProposals (Mode::mode(), Stage::stage());
    }

    /**
     * Replaces the current workflow steps with a new one.
     */
    global boolean SetWizardSteps () {
	// Adjusting the steps this way:
	//   * Disable all steps
	//   * Enable only the requierd ones

	ResetWorkflowSteps();

	ProductControl::DisableAllModulesAndProposals (Mode::mode(), Stage::stage());

	list <map <string, any> > subworkflows =
	    (list <map <string, any> >) ProductFeatures::GetFeature ("globals", "subworkflows");

	boolean found = false;

	foreach (map <string, any> one_subworkflow, subworkflows, {
	    if (one_subworkflow["name"]:"" == update_workflow_type) {
		list <string> modules = (list <string>) one_subworkflow["modules"]:[];
		y2milestone ("Modules to enable: %1", modules);

		if (modules != nil && modules != []) {
		    foreach (string one_module, modules, {
			ProductControl::EnableModule (one_module);
		    });
		}

		list <string> proposals = (list <string>) one_subworkflow["proposals"]:[];
		y2milestone ("Proposals to enable: %1", proposals);

		if (proposals != nil && proposals != []) {
		    foreach (string one_proposal, proposals, {
			ProductControl::EnableProposal (one_proposal);
		    });
		}

		found = true;
		break;
	    }
	});

	if (found != true) {
	    y2error ("Unknown workflow: %1", update_workflow_type);
	    y2milestone ("Known workflows: %1", subworkflows);
	    // TRANSLATORS: error message
	    Report::Error (_("No workflow defined."));
	    return false;
	}

	return true;
    }

    /**
     * Handles the optional workflow steps according to the current settigns.
     */
    global void AdjustVariableSteps () {
	// BNC #579905: Check modified repositories manually.
	if (check_repositories_manually != false) {
	    y2milestone ("Enabling module %1", check_repos_module);
	    ProductControl::EnableModule (check_repos_module);
	} else {
	    y2milestone ("Disabling module %1", check_repos_module);
	    ProductControl::DisableModule (check_repos_module);
	}
    }

    /**
     * Redraws the wizard steps according to current workflow settings.
     */
    global void RedrawWizardSteps () {
	list<map> stage_mode = [
	    $[
		"stage" : Stage::stage(),
		"mode" : Mode::mode()
	    ]
	];

	y2milestone ("Updating wizard steps: %1, Disabled modules: %2, Disabled proposals: %3",
	    stage_mode, ProductControl::GetDisabledModules(), ProductControl::GetDisabledProposals());
	ProductControl::UpdateWizardSteps (stage_mode);
    }

    /**
     * Sets wizard steps and redraws the UI.
     */
    global boolean AdjustWizardSteps () {
	if (SetWizardSteps() != true) {
	    return false;
	}

	RedrawWizardSteps();

	return true;
    }

    /**
     * Initializes internal variables used later
     *
     * @param map <string, any> commands as got from CommandLine::Parse()
     * @see CommandLine module
     */
    global void Init (map <string, any> commands) {
	if (haskey (commands, "command")) {
	    if (commands["command"]:"" == "cd_update") {
		// Backward compatibility
		commands["command"] = "PatchCD";
	    }

	    y2milestone ("Starting workflow defined: %1", commands["command"]:"");
	    SetUpdateWorkflow (commands["command"]:"");
	} else {
	    string default_subworkflow = ProductFeatures::GetStringFeature ("globals", "default_subworkflow");

	    if (default_subworkflow == nil || default_subworkflow == "") default_subworkflow = "manual";
	    y2milestone ("Using default workflow: %1", default_subworkflow);
	}

	AdjustWizardSteps();
    }

    /**
     * Initializes the package manager
     */
    global boolean InitPkg () {
	if (Pkg::TargetInitialize (Installation::destdir) != true) {
	    y2error ("Cannot initialize target");
	    return false;
	}

	if (Pkg::TargetLoad() != true) {
	    y2error ("Cannot load target");
	    return false;
	}

	if (Pkg::SourceStartManager (true) != true) {
	    y2error ("Cannot initialize sources");
	    return false;
	}

	// FIXME: what's missing here?

	return true;
    }

    /**
     * Processes the command-line parameters and prints
     * an appropriate command-line output.
     *
     * @param map <string, any> commands as got from CommandLine::Parse()
     * @see CommandLine module
     */
    global void ProcessCommandLine (map <string, any> commands) {
	Mode::SetUI ("commandline");

	if (commands["command"]:"" == "help" || commands["command"]:"" == "longhelp") {
	    CommandLine::Print(_("
This module does not support command-line interface.
To do so, please, use zypper instead.
"));
	} else if (commands["command"]:"" == "xmlhelp") {
	    if (! haskey (commands["options"]:$[], "xmlfile")) {
		CommandLine::Print(_("Target file name ('xmlfile' option) is missing. Use xmlfile=<target_XML_file> command line option."));
	    } else {
		map doc = $[];

		doc["listEntries"] = $[
		    "commands": "command",
		    "options": "option",
		    "examples": "example",
		];

		doc["systemID"] = Directory::schemadir + "/commandline.dtd";
		doc["typeNamespace"] = "http://www.suse.com/1.0/configns";
		doc["rootElement"] = "commandline";
		XML::xmlCreateDoc(`xmlhelp, doc);

		map exportmap = $[
		    "module" : "wagon",
		];

		XML::YCPToXMLFile(`xmlhelp, exportmap, commands["options", "xmlfile"]:"");
		y2milestone("exported XML map: %1", exportmap);
	    }
	}
    }

    /**
     * Goes through all selected packages one by one a check licenses to confirm.
     * These licenses are requested to be accepted by user. If user declines any
     * of them, a respective package is set to 'Taboo' and new solver run is
     * required.
     *
     * @return boolean whether all licenses have been accepted
     */
    global boolean AcceptLicenses () {
	boolean accepted = true;

	foreach (string p, Pkg::GetPackages (`selected, true), {
	    string license = Pkg::PkgGetLicenseToConfirm (p);

	    if (license != nil && license != "") {
		if (license != nil && license != "") {
		    string rt_license = sformat ("<p><b>%1</b></p>\n%2", p, license);

		    if (! Popup::AnyQuestionRichText (
			// popup heading, with rich text widget and Yes/No buttons
			_("Do you accept this license agreement?"),
			rt_license,
			70, 20,
			Label::YesButton (), Label::NoButton (),
			`focus_none
		    )) {
			y2milestone("License not accepted: %1", p);
			Pkg::PkgTaboo (p);
			accepted = false;
		    } else {
			Pkg::PkgMarkLicenseConfirmed (p);
		    }
		}
	    }
	});

	return accepted;
    }

    map <string, any> GetUpdateConf () {
	map <string, boolean> ret = $[];

	boolean sdp = Update::SilentlyDowngradePackages();
	if (sdp != nil) {
	    ret["silent_downgrades"] = sdp;
	}

	y2milestone ("Using update configuration: %1", ret);

	return ret;
    }

    boolean already_proposed = false;

    global void ResetDUPProposal () {
	already_proposed = false;
    }

    global boolean ProposeDUP () {
	if (already_proposed == true) {
	    y2milestone ("DUP already proposed");
	    return true;
	}

	map <string, any> update_conf = GetUpdateConf();

	map <symbol, integer> update_sum = Pkg::PkgUpdateAll (update_conf);
	y2milestone ("Update configuration: %1, update summary: %2", update_conf, update_sum);

	already_proposed = true;

	return true;
    }

    global map <string,any> MinimizeProductMap (map <string,any> product) {
	if (haskey (product, "license")) product["license"] = "...";
	if (haskey (product, "description")) product["description"] = "...";

	return product;
    }

    string GetDisplayName (string display_name, string name) {
	if (display_name == name)
	    return display_name;

	// 'Product Long Name (product-libzypp-name)'
	return sformat (_("%1 (%2)"), display_name, name);
    }

    global map <string, any> ProposalSummary () {
	string ret = "";
	string warning = "";

	list <map <string,any> > products = sort (
	    map <string,any> x, map <string,any> y, Pkg::ResolvableProperties ("", `product, ""),
	    ``(x["display_name"]:x["short_name"]:x["name"]:"a" < y["display_name"]:x["short_name"]:x["name"]:"b")
	);

	// migration_products contains list of temporary products for migration process

	y2milestone ("All known migration products: %1", migration_products);

	string display_name = nil;
	string name = nil;
	symbol transact_by = nil;

	// list of all products that will be installed (are selected)
	list <string> products_to_be_installed = [];
	foreach (map <string,any> product, products, {
	    if (product["status"]:`unknown != `selected) return;
	    name = product["name"]:_("No short name defined");
	    products_to_be_installed = add (products_to_be_installed, name);
	});

	// list of all products that will be upgraded
	list <string> products_to_be_upgraded = [];

	integer products_removed_by_solver = 0;

	// Products that are going to be removed
	foreach (map <string,any> product, products, {
	    if (product["status"]:`unknown != `removed) return;

	    product = MinimizeProductMap (product);
	    display_name = product["display_name"]:product["short_name"]:product["name"]:_("No name defined");
	    name = product["name"]:_("No short name defined");
	    transact_by = product["transact_by"]:`unknown;

	    // Removing product and installing the same one (name) means -> upgrade
	    if (contains (products_to_be_installed, name)) {
		products_to_be_upgraded = add (products_to_be_upgraded, name);
		y2milestone ("Product to be upgraded: %1 (this is the removed one)", product);
		// Do not list this product as 'to removed', list it as 'to upgrade'
		return;
	    }

	    // Removing a migration product is fine
	    if (contains (migration_products, product["name"]:"")) {
		y2milestone ("Migration product will be removed: %1", product);
		ret = ret + "<li>" + sformat (
		    _("Temporary migration product <b>%1</b> will be removed"),
		    GetDisplayName (display_name, name)
		) + "</li>\n";
	    // Removing another product might be an issue
	    // (nevertheless selected by user or directly by YaST)
	    } else if (transact_by == `user || transact_by == `app_high) {
		y2warning ("Product will be removed: %1 (%2)", product, transact_by);
		ret = ret + "<li>" + sformat (
		    _("<font color='red'><b>Warning:</b> Product <b>%1</b> will be removed</font>"),
		    GetDisplayName (display_name, name)
		) + "</li>\n";
	    // Not selected by user
	    // @see BNC #575117
	    } else {
		y2warning ("Product will be removed: %1 (%2)", product, transact_by);
		ret = ret + "<li>" + sformat (
		    _("<font color='red'><b>Error:</b> Product <b>%1</b> will be automatically removed</font>"),
		    GetDisplayName (display_name, name)
		) + "</li>\n";
		products_removed_by_solver = products_removed_by_solver + 1;
	    }
	});

	// Products that are going to be installed (new ones) or upgraded
	foreach (map <string,any> product, products, {
	    if (product["status"]:`unknown != `selected) return;

	    product = MinimizeProductMap (product);
	    display_name = product["display_name"]:product["short_name"]:product["name"]:_("No name defined");
	    name = product["name"]:_("No short name defined");

	    // Product is going to be upgraded (removed + installed new version)
	    if (contains (products_to_be_upgraded, name)) {
		y2milestone ("Product will be upgraded to: %1 (this is the installed one)", product);
		ret = ret + "<li>" + sformat (
		    _("Product <b>%1</b> will be upgraded"),
		    GetDisplayName (display_name, name)
		) + "</li>\n";
	    // Newly installed product
	    } else {
		y2milestone ("Product will be upgraded: %1", product);
		ret = ret + "<li>" + sformat (
		    _("New product <b>%1</b> will be installed"),
		    GetDisplayName (display_name, name)
		) + "</li>\n";
	    }
	});

	// Products that will keep installed (unchanged)
	foreach (map <string,any> product, products, {
	    if (product["status"]:`unknown != `installed) return;

	    product = MinimizeProductMap (product);
	    display_name = product["display_name"]:product["short_name"]:product["name"]:_("No name defined");
	    name = product["name"]:_("No short name defined");

	    y2milestone ("Product will keep: %1", product);
	    ret = ret + "<li>" + sformat (
		_("Product <b>%1</b> will keep installed"),
		GetDisplayName (display_name, name)
	    ) + "</li>\n";
	});

	ret = "<ul>\n" + ret + "</ul>\n";

	map <string, any> summary = $[
	    "preformatted_proposal" : ret,
	    // help text
	    "help" : _("<p>To change the update settings, go to <p>Packages Proposal</p> section.</p>"),
	];

	// Product removal MUST be confirmed by user, otherwise migration will not continue.
	if (products_removed_by_solver > 0) {
	    summary["warning_level"] = `blocker;
	    summary["warning"] = "<ul>" + (
		products_removed_by_solver > 1 ?
		sformat(_("<li><b>%1 products are going to be removed.
Go to packages proposal and solve the issue manually.<br>
It it also safe to abort the migration now.</b></li>"), products_removed_by_solver)
		:
		_("<li><b>One product is going to be removed.
Go to packages proposal and solve the issue manually.<br>
It it also safe to abort the migration now.</b></li>")
	    ) + "</ul>";
	}

	return summary;
    }

    global list <map <string, string> > ReadProductsBeforeMigration () {
	list <map <string, any> > products = Pkg::ResolvableProperties ("", `product, "");
	y2milestone ("All known products: %1", products);

	foreach (map<string, any> p, products, {
	    if (p["status"]:`unknown != `installed)
		return;

	    // Remember the 'old' product just for the case of reverting
	    products_before_migration = add (
		products_before_migration,
		    $["name" : p["name"]:"", "version" : p["version"]:""]
	    );
	});

	return products_before_migration;
    }

    // YaST can be restarted but some data have to be kept
    string migration_products_store_file = sformat ("%1/wagon_products_before_migration", Directory::vardir);

    global boolean StoreProductsBeforeMigration () {
	return (boolean) SCR::Write (.target.ycp, migration_products_store_file, products_before_migration);
    }

    global boolean RestoreProductsBeforeMigration () {
	products_before_migration = (list <map <string, string> >) SCR::Read (.target.ycp, migration_products_store_file);

	if (products_before_migration == nil) {
	    products_before_migration = [];
	    Report::Error (_("Error restoring the list of previously installed products."));
	    return false;
	}

	return true;
    }

    global string GetFileOwner (string file) {
	if (file == nil || file == "") {
	    y2error ("File not provided");
	    return nil;
	}

	if (! FileUtils::Exists (file)) {
	    y2error ("File %1 doesn't exist", file);
	    return nil;
	}

	string command = sformat ("rpm -qf '%1'", String::Quote (file)) + " --queryformat \"%{NAME}\"";
	map <string, any> cmd = (map <string, any>) SCR::Execute (.target.bash_output, command);
	if (cmd["exit"]:-1 != 0) {
	    y2error ("Cannot get file owner %1: %2", command, cmd);
	    return nil;
	}

	return (string) splitstring (cmd["stdout"]:"", "\n")[0]:nil;
    }

    global boolean RunHook (string script_name) {
	if (script_name == nil || script_name == "") {
	    y2error ("Script name '%1' is not supported", script_name);
	}

	script_name = sformat ("/usr/lib/YaST2/bin/wagon_hook_%1", script_name);

	if (! FileUtils::Exists (script_name)) {
	    y2milestone ("Hook script %1 doesn't exist, nothing to run", script_name);
	    return false;
	}

	y2milestone ("Running hook %1", script_name);
	map cmd = (map) WFM::Execute (.local.bash_output, String::Quote (script_name));

	if (cmd["exit"]:-1 != 0) {
	    y2error ("Hook script returned: %1", cmd);
	    Report::Error (sformat(_("Error running hook script %1."), script_name));
	    return false;
	}

	y2milestone ("Hook script returned: %1", cmd);

	return true;
    }
/* EOF */
}
