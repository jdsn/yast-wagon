/**
 * File:	modules/Wagon.ycp
 * Package:	WAGON
 * Summary:	Functions and handlers for WAGON
 * Authors:	Lukas Ocilka <locilka@suse.cz>
 * Internal
 *
 * $Id$
 *
 * Module for handling WAGON.
 *
 */

{
    module "Wagon";

    textdomain "wagon";

    import "Installation";
    import "PackageCallbacks";
    import "CommandLine";
    import "Mode";
    import "Stage";
    import "Directory";
    import "XML";
    import "ProductControl";
    import "Popup";
    import "Label";

    boolean running_by_applet = false;

    /**
     * Returns whether the application is called from applet
     *
     * @return boolean is_running_by_applet
     */
    global boolean GetRunningByApplet () {
	return running_by_applet;
    }

    global void AdjustWizardSteps () {
	if (GetRunningByApplet()) {
	    // Shortening the workflow
	    ProductControl::DisableModule ("update_url_dialog");
	    ProductControl::DisableModule ("wagon_ownurl");
	    ProductControl::DisableModule ("wagon_selfupdate_from_url");

	    // All modules but this one are disabled
	    ProductControl::EnableModule ("suse_register_after_update");

	// FIXME: PatchCD

	} else {
	    ProductControl::EnableModule ("update_url_dialog");
	    ProductControl::EnableModule ("wagon_ownurl");
	    ProductControl::EnableModule ("wagon_selfupdate_from_url");
	}

	list<map> stage_mode = [
	    $[
		"stage" : Stage::stage(),
		"mode" : Mode::mode()
	    ]
	];

	y2milestone ("Updating wizard steps: %1, Disabled modules: %2",
	    stage_mode, ProductControl::GetDisabledModules());
	ProductControl::UpdateWizardSteps (stage_mode);
    }

    /**
     * Sets whether the application is called from applet
     *
     * @param boolean running_by_applet
     */
    global void SetRunningByApplet (boolean new_value) {
	if (new_value == nil) {
	    y2error ("Erroneous value: %1", new_value);
	    return;
	}

	running_by_applet = new_value;
    }

    /**
     * Initializes internal variables used later
     *
     * @param map <string, any> commands as got from CommandLine::Parse()
     * @see CommandLine module
     */
    global void Init (map <string, any> commands) {
	if (commands["command"]:"" == "running_by_applet") {
	    y2milestone ("Running by applet, switching to automatic mode");
	    SetRunningByApplet (true);
	} else {
	    SetRunningByApplet (false);
	}

	AdjustWizardSteps();
    }

    /**
     * Initializes the package manager
     */
    global boolean InitPkg () {
	if (Pkg::TargetInitialize (Installation::destdir) != true) {
	    y2error ("Cannot initialize target");
	    return false;
	}

	if (Pkg::SourceStartManager (true) != true) {
	    y2error ("Cannot initialize sources");
	    return false;
	}

	return true;
    }

    /**
     * Processes the command-line parameters and prints
     * an appropriate command-line output.
     *
     * @param map <string, any> commands as got from CommandLine::Parse()
     * @see CommandLine module
     */
    global void ProcessCommandLine (map <string, any> commands) {
	Mode::SetUI ("commandline");

	if (commands["command"]:"" == "help" || commands["command"]:"" == "longhelp") {
	    CommandLine::Print(_("
This module does not support command-line interface.
To do so, please, use zypper instead.
"));
	} else if (commands["command"]:"" == "xmlhelp") {
	    if (! haskey (commands["options"]:$[], "xmlfile")) {
		CommandLine::Print(_("Target file name ('xmlfile' option) is missing. Use xmlfile=<target_XML_file> command line option."));
	    } else {
		map doc = $[];

		doc["listEntries"] = $[
		    "commands": "command",
		    "options": "option",
		    "examples": "example",
		];

		doc["systemID"] = Directory::schemadir + "/commandline.dtd";
		doc["typeNamespace"] = "http://www.suse.com/1.0/configns";
		doc["rootElement"] = "commandline";
		XML::xmlCreateDoc(`xmlhelp, doc);

		map exportmap = $[
		    "module" : "wagon",
		];

		XML::YCPToXMLFile(`xmlhelp, exportmap, commands["options", "xmlfile"]:"");
		y2milestone("exported XML map: %1", exportmap);
	    }
	}
    }

    /**
     * Goes through all selected packages one by one a check licenses to confirm.
     * These licenses are requested to be accepted by user. If user declines any
     * of them, a respective package is set to 'Taboo' and new solver run is
     * required.
     *
     * @return boolean whether all licenses have been accepted
     */
    global boolean AcceptLicenses () {
	boolean accepted = true;

	foreach (string p, Pkg::GetPackages (`selected, true), {
	    string license = Pkg::PkgGetLicenseToConfirm (p);

	    if (license != nil && license != "") {
		if (license != nil && license != "") {
		    string rt_license = sformat ("<p><b>%1</b></p>\n%2", p, license);

		    if (! Popup::AnyQuestionRichText (
			// popup heading, with rich text widget and Yes/No buttons
			_("Do you accept this license agreement?"),
			rt_license,
			70, 20,
			Label::YesButton (), Label::NoButton (),
			`focus_none
		    )) {
			y2milestone("License not accepted: %1", p);
			Pkg::PkgTaboo (p);
			accepted = false;
		    } else {
			Pkg::PkgMarkLicenseConfirmed (p);
		    }
		}
	    }
	});

	return accepted;
    }

/* EOF */
}
