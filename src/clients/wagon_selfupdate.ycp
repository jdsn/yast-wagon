/**
 * File:
 *	clients/wagon_selfupdate.ycp
 *
 * Module:
 *	Wagon
 *
 * Authors:
 *	Lukas Ocilka <locilka@suse.cz>
 *
 * Summary:
 *	Online Migration Tool
 *
 * $Id$
 *
 */

{
    textdomain "wagon";

    import "GetInstArgs";
    import "Wagon";
    import "FileUtils";
    import "ProductControl";
    import "ProductFeatures";
    import "Internet";
    import "OnlineUpdateCallbacks";
    import "Popup";
    import "Label";
    import "PackagesUI";
    import "Report";

    include "wagon/common_func.ycp";

    if (GetInstArgs::going_back()) {
	y2milestone ("Going back...");
	return `back;
    }

    /**
     * Tries to upgrade packages got as parameter.
     *
     * @param list <string> of packages
     */
    integer UpgradePackages (list <string> & packages) {
	// Check the input
	packages = filter (string one_package, packages, {
	    return (one_package != nil && one_package != "");
	});

	integer pkgs_affected = 0;

	map <string, list <string> > installed_versions = $[];

	boolean some_packages_selected = false;

	foreach (string one_package, packages, {
	    // All packages of the given name
	    list <map <string, any> > respros = Pkg::ResolvableProperties (one_package, `package, "");

	    // All installed packages of the given name
	    list <map <string, any> > installed = filter (map <string, any> one_respro, respros, {
		return (one_respro["status"]:`unknown == `installed);
	    });

	    // All available packages of the given name
	    list <map <string, any> > available = filter (map <string, any> one_respro, respros, {
		return (one_respro["status"]:`unknown == `available);
	    });

	    // Such package is not installed
	    if (size (installed) < 1) {
		y2milestone ("Package %1 is not installed", one_package);
		return;
	    }

	    // Er, installed but not available
	    if (size (available) < 1) {
		y2warning ("Package %1 is installed but not available", one_package);
		return;
	    }

	    // Remember the installed version(s)
	    installed_versions[one_package] = maplist (map <string,any> one_installed, installed, {
		return one_installed["version"]:"unknown";
	    });

	    // Force upgrade/install
	    y2milestone ("Selecting package %1 for installation", one_package);
	    if (Pkg::ResolvableInstall (one_package, `package) == true) {
		some_packages_selected = true;
	    } else {
		y2error ("Cannot install package %1", one_package);
	    }
	});

	if (some_packages_selected != true) {
	    y2milestone ("No packages have been selected for upgrade");
	    return pkgs_affected;
	}

	// Calling solver to select the best version
	SolverRunWithFeedback();

	y2milestone ("Some packages have been selected, checking...");

	// Check whether the selected version is different to the already installed one
	foreach (string one_package, list <string> previously_installed_versions, installed_versions, {
	    list <map <string, any> > respros = Pkg::ResolvableProperties (one_package, `package, "");

	    // All selected packages of the given name
	    list <map <string, any> > selected = filter (map <string, any> one_respro, respros, {
		return (one_respro["status"]:`unknown == `selected);
	    });

	    // The package of a given name is selected
	    if (size (selected) > 0) {
		boolean selection_differs = false;

		foreach (map <string, any> one_selected, selected, {
		    if (! contains (previously_installed_versions, one_selected["version"]:"some-version")) {
			pkgs_affected = pkgs_affected + 1;
			selection_differs = true;
			break;
		    }
		});

		if (selection_differs != true) {
		    y2milestone ("Selection of packages doesn't differ, neutralizing package: %1", one_package);
		    Pkg::ResolvableNeutral (one_package, `package, false);
		}
	    }
	});

	return pkgs_affected;
    }

    integer UpdateInstalledProducts () {
	integer affected_products = 0;

	list <map <string,any> > products = Pkg::ResolvableProperties ("", `product, "");

	foreach (map<string, any> p, products, {
	    // Product is not installed
	    if (p["status"]:`unknown != `installed) return;

	    // Make the logs readable
	    p["license"] = "...";
	    p["description"] = "...";

	    string product_name = p["name"]:"";
	    string product_version = p["version"]:"";

	    if (product_name == nil || product_name == "") {
		y2error ("Cannot distinguish product name: %1", product_name);
		return;
	    }

	    // Product version is the same but release can be different
	    // product map doesn't contain the release string. To be sure, product will be reinstalled
	    y2milestone ("Upgrading product %1 version %2", product_name, product_version);
	    // The version is the same, release can be different
	    if (Pkg::ResolvableInstall (product_name, `product) != true) {
		Report::Error (sformat(_("Cannot update installed product %1."), product_name));
		return;
	    }

	    affected_products = affected_products + 1;
	});

	return affected_products;
    }

    Wagon::InitPkg();

    list <map <string, any> > products = Pkg::ResolvableProperties ("", `product, "");
    y2milestone ("All known products: %1", products);

    Wagon::ReadProductsBeforeMigration();
    Wagon::StoreProductsBeforeMigration();

    symbol ret = `auto;

    // Patches need solver run
    Pkg::PkgSolve (true);

    // Here the update stack updates itself
    integer selected = Pkg::ResolvablePreselectPatches (`affects_pkg_manager);

    // No patches selected
    if (selected < 1) {
	y2milestone ("There are no patches that would affect the package manager, trying packages...");

	any pkgs = ProductFeatures::GetFeature ("software", "packages_affecting_pkg_manager");

	if (pkgs == nil || pkgs == "" || pkgs == []) {
	    y2warning ("No packages_affecting_pkg_manager provided");
	} else {
	    list <string> packages = (list <string>) pkgs;
	    y2milestone ("Packages to upgrade: %1", packages);
	    selected = UpgradePackages (packages);
	}
    }

    integer products_selected_for_update = UpdateInstalledProducts();
    if (products_selected_for_update > 0) {
	y2milestone ("%1 products were selected for update", products_selected_for_update);
	selected = products_selected_for_update;
    }

    y2milestone ("Selected resolvables: %1", selected);
    if (selected < 1) {
	y2milestone ("Neither patches nor packages for self-update have been selected");
	return ret;
    }

    ret = SolveDependencies();

    if (ret != `abort) {
	// Solver ends with some resolvables changed
	if (Pkg::IsAnyResolvable (`any, `to_install) == true || Pkg::IsAnyResolvable (`any, `to_remove) == true) {
	    y2milestone ("Calling update...");
	    OnlineUpdateCallbacks::RegisterOnlineUpdateCallbacks();
	    any oui_ret = WFM::call ("online_update_install");
	    y2milestone ("Update returned: %1", oui_ret);
	    ret = `restart_same_step;
	} else {
	    y2milestone ("Nothing to install/remove");
	    ret = `auto;
	}
    }

    y2milestone ("Returning: %1", ret);

    return ret;
}
