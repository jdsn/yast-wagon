/**
 * File:
 *	clients/wagon.ycp
 *
 * Module:
 *	Wagon
 *
 * Authors:
 *	Lukas Ocilka <locilka@suse.cz>
 *	Alois Nebel <e-mail address is unknown>
 *
 * Summary:
 *	Online Migration Tool
 *
 * $Id$
 *
 */
{
    import "ProductControl";
    import "Mode";
    import "Stage";
    import "Wizard";
    import "Directory";
    import "FileUtils";
    import "Wagon";
    import "CommandLine";
    import "PackageLock";

    textdomain "wagon";

    // --> CommandLine support 

    list wfm_args = WFM::Args();
    y2milestone ("ARGS: %1", wfm_args);

    map <string, any> commands = CommandLine::Parse (wfm_args);
    y2milestone ("Commands: %1", commands);

    if (commands["command"]:"" == "help" || commands["command"]:"" == "longhelp" || commands["command"]:"" == "xmlhelp") {
	Wagon::ProcessCommandLine (commands);
	return `auto;
    }

    // <-- CommandLine support 

    string do_restart = Directory::vardir + "/restart_yast";

    // Start workflow from step ...
    string current_step_file = Directory::vardir + "/wagon-current_workflow_step";
    // Start with workflow
    string current_workflow_file = Directory::vardir + "/wagon-current_workflow_file";

    integer current_step = 0;

    string custom_workflow_file = "/usr/share/YaST2/control/online_migration.xml";

    boolean Init () {
	ProductControl::custom_control_file = custom_workflow_file;
	ProductControl::Init();

	Mode::SetMode ("update");
	Stage::Set ("normal");

	ProductControl::AddWizardSteps ([$["stage":Stage::stage(), "mode":Mode::mode()]]);

	// Can't acquire packager lock
	if (PackageLock::Check() != true) {
	    return false;
	}

	Wagon::Init (commands);

	return true;
    }

    // In case of restarting YaST, adjust the environment
    // Prepare YaST for restart
    void HandleRet (symbol ret) {
	if (ret == `restart_same_step || ret == `restart_yast || ret == `reboot) {
	    y2milestone ("YaST will be restarted, returned: %1", ret);
	    SCR::Write (.target.ycp, do_restart, "restart_yast");

	    if (ret == `restart_same_step) {
		current_step = ProductControl::CurrentStep();
		// We actually don't want to restart the same step, we want to continue
		// directly with the very next step
		//
		// The current step + 1 == the very next step
		integer next_step = current_step + 1;
		y2milestone ("YaST will be restarted starting from the very next step: %1", next_step);
		SCR::Write (.target.ycp, current_step_file, next_step);

		string current_workflow = Wagon::GetUpdateWorkflow();
		y2milestone ("Current workflow is '%1'", current_workflow);
		SCR::Write (.target.ycp, current_workflow_file, current_workflow);
	    }
	}
    }

    // Checks whether YaST has been restarted
    // Adjust step to start with
    void HandleInit () {
	if (FileUtils::Exists (do_restart)) {
	    y2milestone ("YaST has been restarted");
	    SCR::Execute (.target.remove, do_restart);

	    if (FileUtils::Exists (current_step_file)) {
		current_step = (integer) SCR::Read (.target.ycp, current_step_file);
		SCR::Execute (.target.remove, current_step_file);

		if (current_step == nil || current_step < 0) {
		    y2error ("Current step is %1, running from the beginning", current_step);
		    current_step = 0;
		} else {
		    y2milestone ("Adjusting starting step: %1", current_step);
		}
	    }

	    if (FileUtils::Exists (current_workflow_file)) {
		string workflow_type = (string) SCR::Read (.target.ycp, current_workflow_file);
		SCR::Execute (.target.remove, current_workflow_file);

		if (workflow_type == nil || workflow_type == "") {
		    y2error ("Requested workflow type is invalid: %1", workflow_type);
		} else {
		    y2milestone ("Adjusting required workflow type: %1", workflow_type);
		    Wagon::SetUpdateWorkflow (workflow_type);
		}
	    }
	}
    }

    // main()
    HandleInit();

    Wizard::OpenNextBackStepsDialog();
    Wizard::SetTitleIcon ("yast-update");

    symbol ret = `auto;

    // Exit WAGON if we can't initialize correctly
    if (Init() != true) {
	ret = `abort;
    } else {
	ret = ProductControl::RunFrom (current_step, false);
    }

    Wizard::CloseDialog();

    HandleRet (ret);

    return ret;
}
